## 인덱스

- 데이터의 쓰기 성능을 희생하고 읽기 속도를 높이는 기능
- Hash 인덱스는 매우 빠르게 값에 접근할 수 있지만 값을 변형해서 인덱싱하므로 범위 검색을 할 때 Hash 인덱스를 사용할 수 없음

### B-Tree 인덱스

- B-tree 는 칼럼의 원래 값을 변형시키지 않고 항상 정렬된 상태를 유지
- 인덱스와 실제 데이터가 저장된 데이터는 따로 관리됨
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있음
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 칼럼을 읽기위해선 데이터 파일에서 해당 레코드를 조회하는 작업이 필요
- InnoDB 에서의 테이터 파일 조회
    - 인덱스에 저장되어 있는 PK 값을 이용해 PK 인덱스를 한번 더 검색한 후 PK 인덱스 리프 페이지에 저장되어있는 레코드를 조회
    - 보조 인덱스 검색에서 데이터 레코드를 조회하기 위해서는 PK 를 저장하고 있는 B-Tree 를 한번 더 검색해야함

## B-Tree 인덱스 추가 및 삭제

- 인덱스 키 추가
    1. B-Tree 상의 적절한 위치를 검색하고 레코드의 키 값과 데이터 주소 정보를 리프 노드 저장
    2. 리프노드가 꽉 차서 더이상 저장할 수 없을 경우 리프 노드를 분리해는 작업이 필요

## B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스 페이지의 크기는 인덱스크기와 자식 노드들의 크기
- 가질 수 있는 자식 노드의 크기는 인덱스의 페이지 크기와 키값의 크기에 따라 결정
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어남
- 인덱스를 구성하는 키 값의 크기가 크다면 B-Tree 의 깊이가 깊어져 디스크 읽기가 늘어남
- 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5개 정도 비용이 더 많이 든다고 예측
- 조회해야하는 레코드 수가 전체 테이블의 20~25% 를 넘어서면 인덱스를 이용하지 않고 풀스캔하는 방식으로 처리하는 것이 효율적

## B-Tree 인덱스를 통한 데이터 읽기

- 인덱스 레인지 스캔: 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
- 인덱스 풀 스캔: 인덱스를 처음부터 끝까지 모두 읽는 방식

  ex) 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우

- 인덱스의 리프 노드에서 검색 조건에 일치한 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요
- 커버링 인덱스: 디스크의 레코드를 읽어오지 않고 인덱스 테이블에만 접근

## 클러스터링 인덱스

- 테이블의 프라이머리 키에 대해서만 적용
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 보조 인덱스 B-Tree 와 달리 클러스터링 인덱스의 리프노드에는 레코드의 모든 컬럼이 같이 저장

## 유니크 인덱스

- MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음
- NULL 가능
- 키 값을 쓸 때 중복된 값이 있는지 없는지 체크하는 과정이 필요
- 보조 인덱스와 같은 역할을 동일하게 수행할 수 있음

## 외래키

- 외래키 제약이 설정되면 자동으로 연관돤 테이블의 칼럼에 인덱스 생성
- 자식 테이블의 외래 키 칼럼의 변경은 부모 테이블의 확인이 필요
- 자식 테이블의 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음
- 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제(DELETE CASCADE)

## 인덱스 선정 조건

- 높은 카디널리티
- 낮은 선택도
- 쿼리의 조건의 높은 사용 빈도