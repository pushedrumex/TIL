# Bloom Filter
대용량 데이터에서 중복 검사를 빠르게 하면서 메모리 공간 문제를 해결할 수 있는 것

## 원리
1. 각기 다른 해시 함수 N 개를 준비
2. 입력된 값 v에 대해 N 개의 해시 함수를 적용하여 N 개의 해시값(h1(v), h2(v), ...)을 얻음
3. 각 해시값에 대응하는 블룸 필터 비트 배열의 비트값을 1로 지정
4. 입력된 값 v가 집합에 속해 있는지 검사할 때, N 개의 해시 함수를 적용하여 얻은 N 개의 해시값에 해당하는 블룸 필터 배열의 비트 값이 모두 1이면 집합에 속해 있다고 판단

## 특징
- 어떤 값이 집합에 속하는 지 여부를 검사하는 필터 역할의 확률적 자료구조
- 거짓 긍정이 발생할 수 있음(실제로 값이 존재하지 않지만 중복된 값이 있다고 판단)
- 해시 충돌이 발생할 수 있기 대문에 확률적 자료구조
- 검증 해야할 데이터의 양이 많을 수록 충돌 확률이 증가
- 데이터 양에 따라 해시 함수의 개수와 비트 배열 크기 조절

## 활용
- 데이터가 너무 많아 RDB 나 해시 테이블이나 set 으로 해결이 안되는 경우
- 거짓긍정이 사용되어도 무방한 경우 ex) 아이디 중복 검사

## 예시
- h1(x) = x % 10
- h2(x) = (x / 3) % 10
- h3(x) = (x / 7) % 10

1. x = 10
    - h1(10) = 0
    - h2(10) = 3
    - h3(10) = 1
    - 블룸 필터 비트 : 1101 0000
2. x = 20
    - h1(20) = 0
    - h2(20) = 6
    - h3(20) = 2
    - 블룸 필터 비트 : 1111 0010

### 최종 블룸 필터 비트: 1111 0010

1. 15 가 존재하는가?
    - h1(15) = 5
    - h2(15) = 5
    - h3(15) = 2
    - 블룸 필터 비트 : 0010 0100
    - 최종 블룸 필터 비트: 1111 0010
    - 15 는 존재하지 않음 

2. 20 이 존재하는가?
    - h1(20) = 0
    - h2(20) = 6
    - h3(20) = 2
    - 블룸 필터 비트 : 1010 0010
    - 최종 블룸 필터 비트: 1111 0010
    - 20 은 존재함

3. 70 이 존재하는가?
    - h1(70) = 0
    - h2(70) = 3
    - h3(70) = 0
    - 블룸 필터 비트 : 1001 0010
    - 최종 블룸 필터 비트: 1111 0010
    - 70 은 존재함 -> 실제로는 존재하지 않음(해시 충돌, 확률적)
   