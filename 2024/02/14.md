# 20240214_TIL

## MVCC

- Multi Version Concurrency Control
- 레코드 레벨의 트랜잭션을 지원하는 DBMS 가 제공하는 기능
- 하나의 레코드에 대해 여러 개의 버전을 동시에 관리하는 것
- MVCC 의 목적은 일관된 읽기
- InnoDB 스토리지 엔진은 언두 로그를 이용해 MVCC 를 구현
    1. 1번 사용자가 특정 데이터를 update (커밋은 아직 X)
    2. 버퍼 풀과 디스크에는 변경된 내용 즉시 반영
    3. 언두영역에 변경되기 이전의 내용을 보관
    4. 2번 사용자가 조회 시 트랜잭션 격리 수준에 따라 버퍼풀이나 언두 영역에서 데이터를 반환
    5. 커밋된다면 지금의 디스크 상태를 영구적인 데이터로 만듬
    6. 롤백된다면 언두 영역에 있는 백업된 데이터를 innoDB 버퍼풀과 디스크로 복구하고 언두영역의 내용 삭제
- 언두 로그에 쌓인 버전들을 사용하여 트랜잭션 격리수준에 맞는 데이터를 조회
- commit 을 하면 버퍼풀의 상태를 영구적인 상태로 만듬. 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제됨.
    - 버퍼풀: InnoDB가 액세스 할 때 테이블 및 인덱스 데이터를 캐시하는 메인 메모리 영역
- rollback을 하면 언두 영역에 있는 백업된 데이터를 Innodb 버퍼 풀로 다시 복구하고 언두 영역의 내용을 삭제
- 단점: 트랜잭션이 길 경우 언두 로그가 커짐 → 트랜잭션은 가능한 작게 유지 해야함

## 트랜잭션

- 하나의 논리적인 작업 셋이 100% 적용(COMMIT)되거나 아무것도 적용되지 않아야(ROLLBACK)함을 보장
- Innodb 는 쿼리 중 일부라도 오류가 발생하면 전체를 원상태로 만듬
- 트랜잭션 범위는 최소화하는데 좋음
  - 이유
    1. 데이터베이스의 커넥션 개수는 제한적이며 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션 수가 줄어들기 때문
    2. 메일 전송이나 네트워크를 통한 원격 서버의 통신 작업은 장애가 발생할 경우 웹 서버 뿐만 아니라 db 서버까지 위험해질 수 있으므로 트랜잭션 내에서 제거해야함

## MySQL 엔진의 잠금

- MySQL 에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨이 존재
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치는 반면에, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 같 영향을 미치지 않음

### 글로벌 락

```sql
FLUSH TABLES WITH READ LOCK
```

- 한 세션이 글로벌 락을 획득하면 다른 세션에서는 SELECT 를 제외한 대부분의 DDL, DML 문장 실행 불가

### 테이블 락

```sql
LOCK TABLES table_name [ READ | WRITE ]
```

- 개별 테이블 단위로 설정되는 잠금
- Innodb 에서는 대부분의 DML 쿼리에서는 테이블락이 걸리지 않고 스키마를 변경하는 DDL 쿼리일 경우에만 영향을 미침

### 네임드 락

```sql
SELECT GET_LOCK('lockName', 2)
```

- 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금

### 메타데이터 락

```sql
RENAME TABLE tab_a TO tab_b
```

- 데이터베이스의 객체의 이름이나 구조를 변경하는 경우 묵시적으로 획득하는 잠금

## InnoDB 스토리지 엔진 잠금

### 레코드 락

- 레코드 자체 만을 잠그는 것
- InnoDB 스토리지 엔진은 테이블의 레코드가 아닌 **인덱스의 레코드를 잠금**
- 인덱스를 통해 검색되는 모든 레코드를 잠금
  - 조건문에 인덱스 컬럼이 없다면 테이블을 풀스캔하면서 모든 레코드를 잠금
- 인덱스가 하나도 없는 테이블은 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정
- 인덱스가 여러개라면 더 좁은 범위의 인덱스를 잠금

<aside>
💡 InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 네스트 키 락 또는 갭 락을 사용하지만, PK 또는 유니크 인덱스에 의한 변경 작업은 레코드 자체에 대해서만 락을 건다.

</aside>

### 갭 락

- 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT) 되는 것을 제어

### 넥스트 키 락

- 레코드 락과 갭 락을 합쳐놓은 형태
- 보통은 갭락을 단독으로 사용하지 않고 넥스트키락의 일부로 함께 사용

### 자동 증가 락

- 각 레코드가 중복되지 않고 저장된 순서대로 증가하는 일련번호의 값을 갖기 위한 잠금

## MySQL 격리 수준

- 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것

### READ UNCOMMITTED

- 각 트랜잭션의 변경 내용이 COMMIT 이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션 에서도 보임
- 더티리드: 어떤 트랜잭션에 처리한 작업이 커밋되지 않았는데 다른 트랜잭션에서 볼 수 있는 현상

### READ COMMITTED

- COMMIT 이 완료된 데이터만 다른 트랜잭션에서 조회 가능
- COMMIT 이 완료되지 않았을 경우 다른 트랜잭션에서는 언두 로그의 데이터 조회
- 더티리드가 발생하지 않음
- REPEATABLE READ(항상 같은 결과를 가져와야함) 불가능

### REPEATABLE READ

- InnoDB 스토리지 엔진의 디폴트 격리 수준
- 트랜잭션은 해당 트랜잭션 시작 전에 커밋한 내용만 조회 가능
  - 중간에 다른 트랜잭션이 커밋을 했다면 언두 영역 조회
- 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장
- 팬텀리드: 다른 트랜잭션에 수행한 변경 작업에 의해 레코드가 보였다가 안보였다 하는 현상
- InnoDB 에서 REPEATABLE READ 수준에서는 갭락과 넥스트키락 덕분에 팬텀리드가 발생하지 않음
  - 언두 레코드에는 잠금을 걸 수 없어서 현재 레코드의 값을 가져옴
  - 하지만 예외적으로 non-locking 조회 후, locking 조회를 하는 경우 팬텀 리드 발생

### SERIALIZABLE

- non-locking 조회도 공유 잠금을 획득해야 가능
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없음

## 인덱스

- 데이터의 쓰기 성능을 희생하고 읽기 속도를 높이는 기능
- Hash 인덱스는 매우 빠르게 값에 접근할 수 있지만 값을 변형해서 인덱싱하므로 범위 검색을 할 때 Hash 인덱스를 사용할 수 없음

### B-Tree 인덱스

- B-tree 는 칼럼의 원래 값을 변형시키지 않고 항상 정렬된 상태를 유지
- 인덱스와 실제 데이터가 저장된 데이터는 따로 관리됨
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있음
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 칼럼을 읽기위해선 데이터 파일에서 해당 레코드를 조회하는 작업이 필요
- InnoDB 에서의 테이터 파일 조회
  - 인덱스에 저장되어 있는 PK 값을 이용해 PK 인덱스를 한번 더 검색한 후 PK 인덱스 리프 페이지에 저장되어있는 레코드를 조회
  - 보조 인덱스 검색에서 데이터 레코드를 조회하기 위해서는 PK 를 저장하고 있는 B-Tree 를 한번 더 검색해야함

## B-Tree 인덱스 추가 및 삭제

- 인덱스 키 추가
  1. B-Tree 상의 적절한 위치를 검색하고 레코드의 키 값과 데이터 주소 정보를 리프 노드 저장
  2. 리프노드가 꽉 차서 더이상 저장할 수 없을 경우 리프 노드를 분리해는 작업이 필요

## B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스 페이지의 크기는 인덱스크기와 자식 노드들의 크기
- 가질 수 있는 자식 노드의 크기는 인덱스의 페이지 크기와 키값의 크기에 따라 결정
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어남
- 인덱스를 구성하는 키 값의 크기가 크다면 B-Tree 의 깊이가 깊어져 디스크 읽기가 늘어남
- 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5개 정도 비용이 더 많이 든다고 예측
- 조회해야하는 레코드 수가 전체 테이블의 20~25% 를 넘어서면 인덱스를 이용하지 않고 풀스캔하는 방식으로 처리하는 것이 효율적

## B-Tree 인덱스를 통한 데이터 읽기

- 인덱스 레인지 스캔: 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식
- 인덱스 풀 스캔: 인덱스를 처음부터 끝까지 모두 읽는 방식

  ex) 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우

- 인덱스의 리프 노드에서 검색 조건에 일치한 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요
- 커버링 인덱스: 디스크의 레코드를 읽어오지 않고 인덱스 테이블에만 접근

## 클러스터링 인덱스

- 테이블의 프라이머리 키에 대해서만 적용
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 보조 인덱스 B-Tree 와 달리 클러스터링 인덱스의 리프노드에는 레코드의 모든 컬럼이 같이 저장

## 유니크 인덱스

- MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음
- NULL 가능
- 키 값을 쓸 때 중복된 값이 있는지 없는지 체크하는 과정이 필요
- 보조 인덱스와 같은 역할을 동일하게 수행할 수 있음

## 외래키

- 외래키 제약이 설정되면 자동으로 연관돤 테이블의 칼럼에 인덱스 생성
- 자식 테이블의 외래 키 칼럼의 변경은 부모 테이블의 확인이 필요
- 자식 테이블의 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음
- 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제(DELETE CASCADE)

## 인덱스 선정 조건

- 높은 카디널리티
- 낮은 선택도
- 쿼리의 조건의 높은 사용 빈도