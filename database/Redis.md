## Redis

key-value 구조의 in-memory 데이터 저장소

## in-memory
- 메모리(RAM)에 데이터를 보관하여 디스크의 입출력 접근을 피하고 병목 현상을 예방

## 특징

- 인메모리를 기반으로 처리 속도가 빠름
- 자료형과 명령어가 다양함
- 데이터 영속성 기능 존재
- 레플리케이션/클러스터 기능을 통한 확장성 및 가용성이 높음
- 클라이언트-서버 모델 기반의 요청-응답 통신 가능
- 싱글 스레드 요청 이벤트로 주도적으로 처리

## 단점
- SQL을 사용할 수 없음
- 관계형 데이터베이스에 비해 트랜잭션 처리 기능이 일부 제한됨

## Redis 데이터 타입

### Strings: 가장 기본적인 데이터 타입으로, set 커멘드를 통해 데이터를 저장
- 이미 존재하는 키에 쓰기 작업을 할 경우, 기본적으로 값을 덮어씀
- 값을 SET 할 때 다양한 옵션이 존재
### Lists: 데이터를 순서대로 저장(큐로 사용하기 적절)
- 좌우 끝부분에 요소를 추가 및 삭제하거나 부분적으로 요소를 가져올 수 있음
- 중간부분 점근의 시간복잡도는 O(N)
### Hashes: 하나의 키 안에 여러개의 field 와 value 쌍으로 데이터를 저장
- 하나의 해시 전체 크기가 크면 레디스 클러스터 사용 시, 샤드 간 데이터 분산이 어려워질 수 있음을 주의해야 함
- 하나의 해시에 저장할 수 있는 필드 수는 약 43억개
- 특정 객체의 여러 속성을 String형으로 저장하는 경우, Hash를 사용하여 메모리를 효율적으로 사용할 수 있음
### Sets: 중복되지 않는 문자열의 집합
### Sorted Sets: 중복되지 않는 값을 저장하되, 모든 값을 score 기준을 정렬됨(score 가 같은 경우 사전 순으로 정렬)
### HyperLogLogs: 중복되지 않는 데이터를 카운트할 때 사용
- set형이나 비트맵보다 더 적은 메모리를 사용하여 같은 동작을 할 수 있지만, 오차가 존재
### Streams: 로그를 저장하기 좋은 자료구조
- 데이터가 연속으로 대량 발생하는 상황에서 데이터를 추가할 때 특화된 자료구조
- 과거 데이터도 유지
### Bitmaps: 비트 단위의 데이터 타입으로 비트 단위의 연산 가능
- 메모리 공간을 효율적으로 다룰 수 있음
- 비트맵을 효율적으로 사용하지 않을 경우 메모리 공간이 낭비될 수 있음
## Pub/Sub
- 발행자가 수신자에게 정보를 저장하지 않고 메시지를 보내는 패턴
- `구독자`(수신자)는 `채널`을 구독, `발행자`는 `채널`을 통해 메시지 발행
- 구독자의 메시지 수신이 보장되지 않음, 메시지 이력을 유지해야할 경우 별도로 List 등에 저장해야함

## Redis의 데이터를 영구 저장 (AOF, RDB)

redis의 in-memory 스토어 특징

1. 서버 재시작 시 모든 데이터 유실
2. 복제 기능을 사용해도 사람의 실수 발생 시 데이터 복원 불가
3. Redis 를 캐시 이외의 용도로 사용한다면 적절한 데이터 백업이 필요

### AOF(Append Only File)

데이터를 변경하는 커멘드가 들어오면 커멘드를 디스크에 모두 저장

- 자동 : redis.conf 파일에서 auto-aof-rewrite-percentage 옵션 (크기 기준)
- 수동 : bgrewriteaof 커멘드를 이용해 cli 창에서 수동으로 AOF 파일 재작성

### RDB(Redis DataBase)

저장 당시에 메모리에 존재하는 데이터 그대로를 디스크에 파일로 저장 (스냅샷, 기본적으로 활성된 상태)

- 자동 : redis.conf 파일에서 save 옵션 (시간 기준)

  ex) save 900 1 900초동안 1개 이상의 키가 변경되었다면 RDB 파일을 재작성

- 수동 : bgsave 커멘드를 이용해서 cli 창에서 수동으로 rdb 파일에 저장
    - save 커멘드는 절대 사용 X

### AOF VS RDB

- 백업은 필요하지만 어느 정도의 데이터 손실이 발생해도 괜찮은 경우
    - RDB 단독 사용
    - redis.conf 파일에서 SAVE 옵션을 적절히 사용
- 장애 상황 직전까지의 모든 데이터가 보장되어야할 경우
    - AOF 사용
    - APPENDFSYNC 옵션이 everysec인 경우 최대 1초 사이의 데이터 유실 가능
- 제일 강력한 내구성이 피료한 경우
    - RDB & AOF 동시 사용

## Redis 아키텍처 (Replication, Sentinel, Cluster)

### Replication

단순한 복제 연결

- replicaof 커맨드를 이용해 간단하게 복제 연결
- 비동기식 복제
- HA(고가용, 자동으로 faliover) 기능이 없으므로 Master 에 장애 상황 발생 시 수동 복구
    - replicaof on one
    - 어플리케이션에서 연결 정보 변경

### Sentinel

자동 페일 오버 가능한 HA 구성

- sentinel 노드(모니터링 서버)가 다른 노드(db 서버) 감시
- 마스터가 비정상 상태일 때 자동으로 페일 오버
- 연결 정보 변경 필요 없음

  어플리케이션은 sentinel 노드만 알고 있으면 됨

- sentinel 노드는 항상 3대 이상의 홀수로 존재

  과반수 이상의 sentinel이 동의해야 페일오버 진행


### Cluster

스케일 아웃과 HA 구성

- 키를 여러 노드에 자동으로 분할해서 저장(샤딩)
- 모든 노드가 서로를 감시하여 마스터 비정상일 때 자동 페일오버
- 최소 3대의 마스터 노드가 필요


## Redis가 싱글 스레드임에도 성능이 높은 이유
- 데이터를 디스크가 아닌 메모리에 저장하기 때문에 데이터 접근 속도가 빠름
- 싱글 스레드이기 때문에 컨텍스트 스위칭의 오버헤드가 없고 락을 사용한 동기화 메커니즘이 없음
- **I/O multiplexing**을 통해 싱글 스레드에 여러개의 요청을 처리

### I/O multiplexing
- 유저 레벨에서는 싱글 스레드로 이벤트 루프를 통해 요청을 처리
- 커널 I/O 레벨에서는 멀티 스레드로 요청을 비동기로 처리
- 마치 멀티 스레드 환경 처럼 동작

#### 요청 처리 과정
1. 클라이언트가 소켓을 통해 Redis 서버에 쓰기/읽기 요청
2. 유저 레벨 스레드는 이벤트 루프를 통해 해당 요청을 확인
2. 작업 큐에 작업 추가
3. I/O 스레드가 해당 요청을 처리 
4. 유저 레벨 스레드가 완료된 작업을 한번에 전달
